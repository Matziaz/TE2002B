--------------------------------------------------------------------------------
--
-- This VHDL file was generated by EASE/HDL 8.4 Revision 4 from HDL Works B.V.
--
-- Ease library  : design
-- HDL library   : design
-- Host name     : Laptop-Fer
-- User name     : ferna
-- Time stamp    : Mon Apr 07 09:58:08 2025
--
-- Designed by   : 
-- Company       : 
-- Project info  : 
--
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
-- Object        : Entity design.StateMach
-- Last modified : Tue May 12 11:55:40 2009
--------------------------------------------------------------------------------


library ieee;
use ieee.numeric_std.all;
use ieee.std_logic_1164.all;

entity StateMach is
  port (
    -- Key schedule
    KeyEn      : out std_logic;
    KeyFin     : in  std_logic;
    KeySel     : out std_logic_vector(3 downto 0);

    -- AddRoundKey instances
    AddRoundu0En  : out std_logic;  -- initial round
    AddRoundu0Fin : in  std_logic;
    AddRoundu4En  : out std_logic;  -- full rounds
    AddRoundu4Fin : in  std_logic;
    AddRoundu7En  : out std_logic;  -- final round
    AddRoundu7Fin : in  std_logic;

    -- Inverse ShiftRows instances
    InvShiftRowsu2En  : out std_logic;
    InvShiftRowsu2Fin : in  std_logic;
    InvShiftRowsu6En  : out std_logic;
    InvShiftRowsu6Fin : in  std_logic;

    -- Inverse SubBytes instances
    InvSubBytesu1En  : out std_logic;
    InvSubBytesu1Fin : in  std_logic;
    InvSubBytesu5En  : out std_logic;
    InvSubBytesu5Fin : in  std_logic;

    -- Inverse MixColumns instance
    InvMixColumnsu3En  : out std_logic;
    InvMixColumnsu3Fin : in  std_logic;

    -- Mux select
    MuxSel : out std_logic;

    -- Clock and reset
    Clk : in std_logic;
    Rst : in std_logic
  );
end entity;

architecture rtl of StateMach is

  type state_t is (
    IDLE, KEY_EXP, ADD0,
    ROUNDS_START, SR, SB, ADD, MC,
    FINAL_SR, FINAL_SB, FINAL_ADD,
    DONE
  );

  signal state, next_state : state_t;
  signal round_counter : integer range 0 to 9;

begin

  -- State register
  process(Clk, Rst)
  begin
    if Rst = '1' then
      state <= IDLE;
      round_counter <= 0;
    elsif rising_edge(Clk) then
      state <= next_state;
      if state = ADD then
        if round_counter < 8 and AddRoundu4Fin = '1' then
          round_counter <= round_counter + 1;
        end if;
      elsif state = FINAL_ADD and AddRoundu7Fin = '1' then
        round_counter <= 0;
      end if;
    end if;
  end process;

  -- Next state logic
  process(state, KeyFin, AddRoundu0Fin, 
          InvShiftRowsu2Fin, InvSubBytesu1Fin,
          InvMixColumnsu3Fin, AddRoundu4Fin,
          InvShiftRowsu6Fin, InvSubBytesu5Fin,
          AddRoundu7Fin, round_counter)
  begin
    next_state <= state;
    case state is

      when IDLE =>
        next_state <= KEY_EXP;

      when KEY_EXP =>
        if KeyFin = '1' then
          next_state <= ADD0;
        end if;

      when ADD0 =>
        if AddRoundu0Fin = '1' then
          next_state <= ROUNDS_START;
        end if;

      when ROUNDS_START =>
        next_state <= SR;

      when SR =>
        if InvShiftRowsu2Fin = '1' then
          next_state <= SB;
        end if;

      when SB =>
        if InvSubBytesu1Fin = '1' then
          next_state <= ADD;
        end if;

      when ADD =>
        if AddRoundu4Fin = '1' then
          if round_counter = 8 then
            next_state <= FINAL_SR;
          else
            next_state <= MC;
          end if;
        end if;

      when MC =>
        if InvMixColumnsu3Fin = '1' then
          next_state <= SR;
        end if;

      when FINAL_SR =>
        if InvShiftRowsu6Fin = '1' then
          next_state <= FINAL_SB;
        end if;

      when FINAL_SB =>
        if InvSubBytesu5Fin = '1' then
          next_state <= FINAL_ADD;
        end if;

      when FINAL_ADD =>
        if AddRoundu7Fin = '1' then
          next_state <= DONE;
        end if;

      when DONE =>
        next_state <= DONE;

      when others =>
        next_state <= IDLE;

    end case;
  end process;

  -- Output enables

  -- Key Expansion
  KeyEn <= '1' when state = KEY_EXP else '0';

  -- AddRoundKey inicial (u0)
  AddRoundu0En <= '1' when state = ADD0 else '0';

  -- AddRoundKey durante rondas (u4)
  AddRoundu4En <= '1' when state = ADD else '0';

  -- AddRoundKey final (u7)
  AddRoundu7En <= '1' when state = FINAL_ADD else '0';

  -- InvShiftRows para rondas
  InvShiftRowsu2En <= '1' when state = SR else '0';

  -- InvSubBytes para rondas
  InvSubBytesu1En <= '1' when state = SB else '0';

  -- InvMixColumns para rondas
  InvMixColumnsu3En <= '1' when state = MC else '0';

  -- InvShiftRows para ronda final
  InvShiftRowsu6En <= '1' when state = FINAL_SR else '0';

  -- InvSubBytes para ronda final
  InvSubBytesu5En <= '1' when state = FINAL_SB else '0';

  -- Mux select: '0' en rondas normales, '1' en final
  MuxSel <= '0' when state = SR or state = SB or state = ADD or state = MC else
            '1' when state = FINAL_SR or state = FINAL_SB or state = FINAL_ADD else
            '0';

  -- KeySel: para seleccionar la subclave adecuada
  with state select
    KeySel <=
      "0000" when KEY_EXP | ADD0,
      std_logic_vector(to_unsigned(round_counter + 1, 4)) when SR | SB | ADD | MC,
      "1010" when FINAL_SR | FINAL_SB | FINAL_ADD,
      "0000" when others;

end architecture rtl;
